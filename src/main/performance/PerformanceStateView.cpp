#include "PerformanceStateView.hpp"

#include "performance/PerformanceState.hpp"

#include <stdexcept>

using namespace mpc;
using namespace mpc::performance;

PerformanceStateView::PerformanceStateView(
    const PerformanceState *const s) noexcept
    : state(s)
{
}

bool PerformanceStateView::isProgramPadPressed(
    const ProgramPadIndex idx, const ProgramIndex programIndex) const
{
    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex == idx && e.programIndex == programIndex)
        {
            return true;
        }
    }
    return false;
}

VelocityOrPressure
PerformanceStateView::getPressedProgramPadAfterTouchOrVelocity(
    const ProgramPadIndex idx) const
{
    VelocityOrPressure result;

    for (const auto &e : state->programPadEvents)
    {
        if (e.source == PerformanceEventSource::NoteRepeat)
        {
            continue;
        }

        if (e.padIndex == idx)
        {
            if (e.pressure != NoPressure)
            {
                result = e.pressure;
            }
            else if (result == NoVelocityOrPressure)
            {
                result = e.velocity;
            }
        }
    }

    if (result != NoVelocityOrPressure)
    {
        return result;
    }

    throw std::invalid_argument(
        "This method should only be called for program pads that are "
        "pressed, and the presses shouldn't be generated by the note repeat "
        "feature.\n");
}

bool PerformanceStateView::isProgramPadPressed(const ProgramPadIndex idx) const
{
    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex == idx)
        {
            return true;
        }
    }
    return false;
}

std::optional<ProgramPadPressEvent>
PerformanceStateView::getMostRecentProgramPadPress(
    const ProgramPadIndex idx,
    const std::initializer_list<PerformanceEventSource> &sourcesToExclude) const
{
    std::optional<ProgramPadPressEvent> latest = std::nullopt;

    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex != idx)
        {
            continue;
        }

        bool excluded = false;
        for (auto &s : sourcesToExclude)
        {
            if (e.source == s)
            {
                excluded = true;
                break;
            }
        }
        if (excluded)
        {
            continue;
        }

        if (!latest || e.pressTimeMs > latest->pressTimeMs)
        {
            latest = e;
        }
    }

    return latest;
}

int PerformanceStateView::getTotalNoteOnCount() const
{
    return state->noteEvents.size();
}

Program PerformanceStateView::getProg(const ProgramIndex programIndex) const
{
    return state->programs[programIndex];
}

Program
PerformanceStateView::getDrumProgram(const DrumBusIndex drumBusIndex) const
{
    return getProg(state->drums[drumBusIndex].programIndex);
}

Drum PerformanceStateView::getDrum(const DrumBusIndex drumBusIndex) const
{
    return state->drums[drumBusIndex];
}

std::optional<NoteOnEvent>
PerformanceStateView::findNoteOnEvent(PerformanceEventSource source,
                                      NoteNumber noteNumber,
                                      MidiChannel midiInputChannel)
{
    if (const auto it = std::find_if(
            state->noteEvents.begin(), state->noteEvents.end(),
            [&](const auto &n)
            {
                return n.source == source && n.noteNumber == noteNumber &&
                       (n.source != PerformanceEventSource::MidiInput ||
                        n.midiInputChannel == midiInputChannel);
            });
        it != state->noteEvents.end())
    {
        return *it;
    }

    return std::nullopt;
}

std::optional<PhysicalPadPressEvent>
PerformanceStateView::findPhysicalPadPress(PhysicalPadIndex padIndex)
{
    if (const auto it = std::find_if(state->physicalPadEvents.begin(),
                                     state->physicalPadEvents.end(),
                                     [&](const auto &n)
                                     {
                                         return n.padIndex == padIndex;
                                     });
        it != state->physicalPadEvents.end())
    {
        return *it;
    }

    return std::nullopt;
}

std::optional<ProgramPadPressEvent>
PerformanceStateView::findProgramPadPress(const PerformanceEventSource source,
                                          const ProgramPadIndex programPadIndex,
                                          const ProgramIndex programIndex) const
{
    for (auto &p : state->programPadEvents)
    {
        if (p.source == source && p.padIndex == programPadIndex &&
            p.programIndex == programIndex)
        {
            return p;
        }
    }

    return std::nullopt;
}
