#include "StateView.hpp"

#include "eventregistry/State.hpp"

using namespace mpc;
using namespace mpc::eventregistry;

bool StateView::isProgramPadPressed(const ProgramPadIndex idx,
                                    const ProgramIndex programIndex) const
{
    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex == idx && e.programIndex == programIndex)
        {
            return true;
        }
    }
    return false;
}

bool StateView::isProgramPadPressedBySource(const ProgramPadIndex idx,
                                            const Source src) const
{
    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex == idx && e.source == src)
        {
            return true;
        }
    }
    return false;
}

VelocityOrPressure StateView::getPressedProgramPadAfterTouchOrVelocity(
    const ProgramPadIndex idx) const
{
    VelocityOrPressure result;

    for (const auto &e : state->programPadEvents)
    {
        if (e.source == Source::NoteRepeat)
        {
            continue;
        }

        if (e.padIndex == idx)
        {
            if (e.pressure != NoPressure)
            {
                result = e.pressure;
            }
            else if (result == NoVelocityOrPressure)
            {
                result = e.velocity;
            }
        }
    }

    if (result != NoVelocityOrPressure)
    {
        return result;
    }

    throw std::invalid_argument(
        "This method should only be called for program pads that are "
        "pressed, and the presses shouldn't be generated by the note repeat "
        "feature.\n");
}

bool StateView::isProgramPadPressed(const ProgramPadIndex idx) const
{
    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex == idx)
        {
            return true;
        }
    }
    return false;
}

std::optional<ProgramPadPressEvent> StateView::getMostRecentProgramPadPress(
    const ProgramPadIndex idx,
    const std::vector<Source> &sourcesToExclude) const
{
    std::optional<ProgramPadPressEvent> latest = std::nullopt;

    for (auto &e : state->programPadEvents)
    {
        if (e.padIndex != idx)
        {
            continue;
        }

        bool excluded = false;
        for (auto &s : sourcesToExclude)
        {
            if (e.source == s)
            {
                excluded = true;
                break;
            }
        }
        if (excluded)
        {
            continue;
        }

        if (!latest || e.pressTimeMs > latest->pressTimeMs)
        {
            latest = e;
        }
    }

    return latest;
}

// std::shared_ptr<sequencer::NoteOnEvent>
// StateView::retrieveRecordNoteEvent(const NoteNumber note) const
// {
//     for (const auto &e : state->noteEvents)
//     {
//         if (e.noteNumber == note && e.recordNoteEvent)
//         {
//             return *e->recordNoteEvent;
//         }
//     }
//     return {};
// }

PhysicalPadPressEvent
StateView::retrievePhysicalPadPressEvent(const PhysicalPadIndex idx) const
{
    for (const auto &e : state->physicalPadEvents)
    {
        if (e.padIndex == idx)
        {
            return e;
        }
    }

    throw std::invalid_argument(
        "This method should only be called for physical pads that are "
        "pressed");
}

int StateView::getTotalPressedProgramPadCount() const
{
    return state->programPadEvents.size();
}

int StateView::getTotalNoteOnCount() const
{
    return state->noteEvents.size();
}
